@* File: Components/Pages/Chess.razor *@
@page "/chess"
@rendermode InteractiveServer
@using System.Linq
@using System.Runtime.ConstrainedExecution
@using System.Net.Http;
@using System.Threading.Tasks;
@using System.Text.Json;


<PageTitle>Chess</PageTitle>
<style>
.chess-board {
    border-collapse: collapse;
    user-select: none;
    margin: 12px 0;
}
.chess-board td {
    width: 56px;
    height: 56px;
    text-align: center;
    vertical-align: middle;
    font-size: 32px;
    font-weight: bold;
    cursor: pointer;
    padding: 0;
}
.square-light { background: #b9c3ff; }
.square-dark  { background: #4a8fe9; }
.selected { outline: 3px solid #4CAF50; }
.move-target { background: rgba(76,175,80,0.45) !important; }
.controls { margin: 10px 0; display: flex; gap: 8px; align-items: center; }
.info { font-family: Arial, Helvetica, sans-serif; }
.reset-btn {
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid #aaa;
    background: #fff;
    cursor: pointer;
}
.reset-btn:hover { background: #f3f3f3; }
.small { font-size: 13px; color: #333; }
</style>

<div class="controls">
    <div class="info">
        <div><strong>Turn:</strong> @((WhiteTurn) ? "White" : "Black")</div>
        <div class="small">Click a piece to select it, then click a highlighted square to move. No castling/en-passant; pawns auto-promote to queen.</div>
    </div>
    <button class="reset-btn" @onclick="ResetBoard">Reset</button>
</div>

<table class="chess-board">
    @for (int r = 0; r < 8; r++)
    {
        <tr>
            @for (int c = 0; c < 8; c++)
            {
                var displayRow = r;
                var displayCol = c;
                var isLight = (r + c) % 2 == 0;
                var css = isLight ? "square-light" : "square-dark";
                if (selectedRow == displayRow && selectedCol == displayCol)
                {
                    css += " selected";
                }
                else if (PossibleMove(displayRow, displayCol))
                {
                    css += " move-target";
                    
                }
                <td class="@css" @onclick="() => OnCellClick(displayRow, displayCol)">
                    @CellGlyph(displayRow, displayCol)
                </td>
            }
        </tr>
    }
</table>

@code {
    enum PieceType { King, Queen, Rook, Bishop, Knight, Pawn }
    class Image{

    }
    class Piece
    {
        public PieceType Type { get; set; }
        public bool IsWhite { get; set; }
        public Piece(PieceType t, bool white) { Type = t; IsWhite = white; }
        public Piece Clone() => new Piece(Type, IsWhite);
    }

    Piece[,] board = new Piece[8,8];
    int selectedRow = -1, selectedCol = -1;
    List<(int r,int c)> validMoves = new();
    bool WhiteTurn = true;

    protected override void OnInitialized()
    {
        ResetBoard();
    }

    void ResetBoard()
    {
        Array.Clear(board, 0, board.Length);

        // Black pieces - row 0
        board[0,0] = new Piece(PieceType.Rook, false);
        board[0,1] = new Piece(PieceType.Knight, false);
        board[0,2] = new Piece(PieceType.Bishop, false);
        board[0,3] = new Piece(PieceType.Queen, false);
        board[0,4] = new Piece(PieceType.King, false);
        board[0,5] = new Piece(PieceType.Bishop, false);
        board[0,6] = new Piece(PieceType.Knight, false);
        board[0,7] = new Piece(PieceType.Rook, false);
        for (int c = 0; c < 8; c++) board[1,c] = new Piece(PieceType.Pawn, false);

        // White pieces
        board[7,0] = new Piece(PieceType.Rook, true);
        board[7,1] = new Piece(PieceType.Knight, true);
        board[7,2] = new Piece(PieceType.Bishop, true);
        board[7,3] = new Piece(PieceType.Queen, true);
        board[7,4] = new Piece(PieceType.King, true);
        board[7,5] = new Piece(PieceType.Bishop, true);
        board[7,6] = new Piece(PieceType.Knight, true);
        board[7,7] = new Piece(PieceType.Rook, true);
        for (int c = 0; c < 8; c++) board[6,c] = new Piece(PieceType.Pawn, true);

        selectedRow = selectedCol = -1;
        validMoves.Clear();
        WhiteTurn = true;
    }

   
    void OnCellClick(int r, int c)
    {
        var p = board[r,c];
        // If selecting own piece
        if (p != null && p.IsWhite == WhiteTurn)
        {
            if (selectedRow == r && selectedCol == c)
            {
                // Deselect
                selectedRow = selectedCol = -1;
                validMoves.Clear();
            }
            else
            {
                selectedRow = r;
                selectedCol = c;
                validMoves = GetLegalMoves(r, c);
            }
            return;
        }

        // If clicking a highlighted move target, make move
        if (selectedRow >= 0 && PossibleMove(r, c))
        {
            MakeMove(selectedRow, selectedCol, r, c);
            selectedRow = selectedCol = -1;
            validMoves.Clear();
            WhiteTurn = !WhiteTurn;
        }
        else
        {
            // clicked empty or opponent piece not in targets: clear selection
            selectedRow = selectedCol = -1;
            validMoves.Clear();
        }
    }

    bool PossibleMove(int r, int c) => validMoves.Any(m => m.r == r && m.c == c);

    void MakeMove(int fromR, int fromC, int toR, int toC)
    {
        var p = board[fromR, fromC];
        if (p == null) return;
        board[toR, toC] = p;
        board[fromR, fromC] = null;

        // Pawn promotion to queen when reaching last rank
        if (p.Type == PieceType.Pawn)
        {
            if ((p.IsWhite && toR == 0) || (!p.IsWhite && toR == 7))
            {
                board[toR, toC] = new Piece(PieceType.Queen, p.IsWhite);
            }
        }

    }

    List<(int r,int c)> GetLegalMoves(int r, int c)
    {
        var moves = new List<(int,int)>();
        var p = board[r,c];
        if (p == null) return moves;

        bool enemy(Piece q) => q != null && q.IsWhite != p.IsWhite;
        bool empty(int rr, int cc) => IsInside(rr,cc) && board[rr,cc] == null;

        switch (p.Type)
        {
            case PieceType.Pawn:
                int dir = p.IsWhite ? -1 : 1;
                int startRow = p.IsWhite ? 6 : 1;
                // forward 1
                if (IsInside(r+dir,c) && board[r+dir,c] == null) moves.Add((r+dir,c));
                // forward 2
                if (r == startRow && IsInside(r+2*dir,c) && board[r+dir,c] == null && board[r+2*dir,c] == null)
                    moves.Add((r+2*dir,c));
                // captures
                foreach (var dc in new int[] { -1, 1 })
                {
                    int rr = r + dir, cc = c + dc;
                    if (IsInside(rr,cc) && enemy(board[rr,cc])) moves.Add((rr,cc));
                }
                break;

            case PieceType.Knight:
                foreach (var d in new (int,int)[]{ (2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2) })
                {
                    int rr = r + d.Item1, cc = c + d.Item2;
                    if (IsInside(rr,cc) && (board[rr,cc] == null || enemy(board[rr,cc]))) moves.Add((rr,cc));
                }
                break;

            case PieceType.Bishop:
                moves.AddRange(SlideMoves(r,c, new (int,int)[]{ (1,1),(1,-1),(-1,1),(-1,-1) }, p.IsWhite));
                break;

            case PieceType.Rook:
                moves.AddRange(SlideMoves(r,c, new (int,int)[]{ (1,0),(-1,0),(0,1),(0,-1) }, p.IsWhite));
                break;

            case PieceType.Queen:
                moves.AddRange(SlideMoves(r,c, new (int,int)[]{ (1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1) }, p.IsWhite));
                break;

            case PieceType.King:
                foreach (var d in new (int,int)[]{ (1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1) })
                {
                    int rr = r + d.Item1, cc = c + d.Item2;
                    if (IsInside(rr,cc) && (board[rr,cc] == null || enemy(board[rr,cc]))) moves.Add((rr,cc));
                }
                break;
        }

        // Note: This simple move generator does not check for checks. It only enforces piece movement/capture.
        return moves;
    }

    IEnumerable<(int,int)> SlideMoves(int r, int c, (int,int)[] directions, bool isWhite)
    {
        var list = new List<(int,int)>();
        foreach (var d in directions)
        {
            int rr = r + d.Item1, cc = c + d.Item2;
            while (IsInside(rr,cc))
            {
                if (board[rr,cc] == null)
                {
                    list.Add((rr,cc));
                }
                else
                {
                    if (board[rr,cc].IsWhite != isWhite) list.Add((rr,cc));
                    break;
                }
                rr += d.Item1; cc += d.Item2;
            }
        }
        return list;
    }

    bool IsInside(int r, int c) => r >= 0 && r < 8 && c >= 0 && c < 8;

    RenderFragment CellGlyph(int row, int col) => builder =>
{
    var piece = board[row, col]; // e.g. "wP"
    if (piece is null)
        return;

    string pieceSVGname = piece.IsWhite ? "w" : "b";
    switch (piece.Type){
        case PieceType.King:
            pieceSVGname += "ki";
            break;
        case PieceType.Queen:
            pieceSVGname += "q";
            break;
        case PieceType.Rook:
            pieceSVGname += "r";
            break;
        case PieceType.Bishop:
            pieceSVGname += "b";
            break;
        case PieceType.Knight:
            pieceSVGname += "kn";
            break;
        case PieceType.Pawn:
            pieceSVGname += "p";
            break;
    }
    var path = $"/chess/pieces/{pieceSVGname}.svg";

    builder.AddMarkupContent(0, $"<img src=\"{path}\" class=\"piece\" />");
};
    
}